#!/usr/bin/env python3
"""
Chaos Theory Analysis Agent

An agent specialized in chaos theory analysis and complex systems modeling.
This agent can analyze nonlinear systems, identify attractors, calculate Lyapunov exponents,
and perform fractal analysis on complex datasets.

Capabilities:
- Nonlinear dynamics analysis
- Bifurcation analysis and visualization
- Attractor identification and classification
- Lyapunov exponent calculation
- Fractal dimension estimation
- Phase space reconstruction

Generated by Autonomous Agent Creator
"""

import os
import sys
import json
import logging
import asyncio
import uuid
import numpy as np
import scipy as sp
from scipy import integrate
import matplotlib.pyplot as plt
from sympy import symbols, diff, solve
import networkx as nx
from typing import Dict, List, Any, Optional, Tuple, Union, Callable
from datetime import datetime
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class ChaosTheoryAnalysisAgent:
    """
    An agent specialized in chaos theory analysis and complex systems modeling.
    
    This agent provides tools for analyzing nonlinear dynamical systems,
    identifying chaotic behavior, and visualizing complex system dynamics.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.id = str(uuid.uuid4())
        self.name = "Chaos Theory Analysis Agent"
        self.created_at = datetime.now().isoformat()
        self.config = config or {}
        self.capabilities = ["nonlinear_dynamics", "bifurcation_analysis", 
                            "attractor_identification", "lyapunov_exponents", 
                            "fractal_analysis"]
        self.specialization = "chaos_theory"
        self.running = False
        self.results_dir = self.config.get("results_dir", "./chaos_results")
        os.makedirs(self.results_dir, exist_ok=True)
        logger.info(f"Initialized {self.name} agent with ID {self.id}")
        
    async def start(self):
        """Start the agent"""
        self.running = True
        logger.info(f"Started {self.name} agent")
        
    async def stop(self):
        """Stop the agent"""
        self.running = False
        logger.info(f"Stopped {self.name} agent")
        
    async def run(self):
        """Main execution loop"""
        self.running = True
        try:
            while self.running:
                # Main agent logic here
                await self._process_cycle()
                await asyncio.sleep(1)  # Prevent CPU hogging
        except Exception as e:
            logger.error(f"Error in agent execution: {e}")
            self.running = False
        finally:
            logger.info(f"Agent {self.name} execution completed")
            
    async def _process_cycle(self):
        """Process a single execution cycle"""
        # Implement the core agent logic here
        pass
    
    async def analyze_logistic_map(self, r_min: float = 2.8, r_max: float = 4.0, 
                                  n_points: int = 1000, iterations: int = 1000, 
                                  warmup: int = 100) -> Dict[str, Any]:
        """
        Analyze the logistic map x_{n+1} = r * x_n * (1 - x_n) for different r values.
        
        Args:
            r_min: Minimum r value
            r_max: Maximum r value
            n_points: Number of r values to analyze
            iterations: Number of iterations for each r value
            warmup: Number of initial iterations to discard
            
        Returns:
            Dictionary with analysis results
        """
        logger.info(f"Analyzing logistic map from r={r_min} to r={r_max}")
        
        r_values = np.linspace(r_min, r_max, n_points)
        results = []
        
        for r in r_values:
            x = 0.5  # Initial value
            
            # Warmup iterations
            for _ in range(warmup):
                x = r * x * (1 - x)
                
            # Collect iterations after warmup
            values = []
            for _ in range(iterations):
                x = r * x * (1 - x)
                values.append(x)
                
            results.append(values)
            
        # Create bifurcation diagram
        plt.figure(figsize=(12, 8))
        for i, r in enumerate(r_values):
            plt.plot([r] * len(results[i]), results[i], ',k', alpha=0.1)
        plt.xlabel('r')
        plt.ylabel('x')
        plt.title('Bifurcation Diagram of Logistic Map')
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/logistic_map_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return {
            "r_values": r_values.tolist(),
            "bifurcation_points": self._find_bifurcation_points(r_values, results),
            "diagram_path": filename,
            "chaos_onset": self._estimate_chaos_onset(r_values, results)
        }
    
    def _find_bifurcation_points(self, r_values: np.ndarray, 
                               results: List[List[float]]) -> List[Dict[str, Any]]:
        """Find approximate bifurcation points in the logistic map"""
        bifurcation_points = []
        
        # Analyze the last 20% of each result to determine period
        for i, r in enumerate(r_values):
            if i == 0:
                continue
                
            values = results[i][-len(results[i])//5:]
            unique_values = set()
            
            for val in values:
                # Round to handle floating point issues
                rounded = round(val, 6)
                if len(unique_values) < 20:  # Limit to avoid detecting chaos as high period
                    unique_values.add(rounded)
            
            period = len(unique_values)
            
            # Check if period changed from previous r value
            if i > 1:
                prev_values = results[i-1][-len(results[i-1])//5:]
                prev_unique = set(round(val, 6) for val in prev_values)
                prev_period = len(prev_unique)
                
                if period != prev_period:
                    bifurcation_points.append({
                        "r_value": float(r),
                        "from_period": prev_period,
                        "to_period": period
                    })
        
        return bifurcation_points
    
    def _estimate_chaos_onset(self, r_values: np.ndarray, 
                            results: List[List[float]]) -> float:
        """Estimate the onset of chaos in the logistic map"""
        # A simple heuristic: find where the number of unique values jumps significantly
        for i, r in enumerate(r_values):
            if i < 10:  # Skip the first few values
                continue
                
            values = results[i][-100:]  # Last 100 values
            unique_values = set(round(val, 6) for val in values)
            
            if len(unique_values) > 20:  # Arbitrary threshold for chaos
                return float(r)
                
        return float(r_values[-1])  # Default to the last r value
    
    async def calculate_lyapunov_exponent(self, system_func: Callable, 
                                        initial_state: np.ndarray,
                                        t_span: Tuple[float, float],
                                        perturbation: float = 1e-10,
                                        dt: float = 0.01) -> Dict[str, Any]:
        """
        Calculate the Lyapunov exponent for a dynamical system.
        
        Args:
            system_func: Function defining the system dynamics (dx/dt = f(x, t))
            initial_state: Initial state vector
            t_span: Time span for integration (t_start, t_end)
            perturbation: Size of perturbation for Lyapunov calculation
            dt: Time step for integration
            
        Returns:
            Dictionary with Lyapunov exponents and system trajectory
        """
        logger.info(f"Calculating Lyapunov exponent for system with {len(initial_state)} dimensions")
        
        # Time points
        t = np.arange(t_span[0], t_span[1], dt)
        
        # Integrate the original system
        sol = sp.integrate.solve_ivp(
            system_func, 
            t_span, 
            initial_state, 
            t_eval=t,
            method='RK45'
        )
        
        # Calculate Lyapunov exponents for each dimension
        lyapunov_exponents = []
        for dim in range(len(initial_state)):
            # Create perturbed initial condition
            perturbed_state = initial_state.copy()
            perturbed_state[dim] += perturbation
            
            # Integrate perturbed system
            perturbed_sol = sp.integrate.solve_ivp(
                system_func, 
                t_span, 
                perturbed_state, 
                t_eval=t,
                method='RK45'
            )
            
            # Calculate divergence over time
            original = sol.y
            perturbed = perturbed_sol.y
            
            # Calculate distances between trajectories
            distances = np.sqrt(np.sum((original - perturbed)**2, axis=0))
            
            # Calculate Lyapunov exponent (average rate of divergence)
            # λ = (1/t) * ln(d(t)/d(0))
            non_zero_distances = distances[distances > 0]
            non_zero_times = t[:len(non_zero_distances)]
            
            if len(non_zero_distances) > 1:
                # Use linear regression on log of distances
                log_distances = np.log(non_zero_distances / perturbation)
                lyapunov = np.polyfit(non_zero_times, log_distances, 1)[0]
            else:
                lyapunov = 0.0
                
            lyapunov_exponents.append(float(lyapunov))
        
        # Create visualization
        plt.figure(figsize=(12, 8))
        
        # Plot trajectory
        if len(initial_state) >= 2:
            plt.subplot(2, 1, 1)
            plt.plot(sol.y[0], sol.y[1])
            plt.title('Phase Space Trajectory')
            plt.xlabel('x')
            plt.ylabel('y')
            
            plt.subplot(2, 1, 2)
        
        # Plot divergence
        plt.semilogy(t, distances)
        plt.title('Trajectory Divergence')
        plt.xlabel('Time')
        plt.ylabel('Distance (log scale)')
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/lyapunov_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return {
            "lyapunov_exponents": lyapunov_exponents,
            "max_lyapunov": max(lyapunov_exponents),
            "is_chaotic": any(lya > 0 for lya in lyapunov_exponents),
            "plot_path": filename,
            "trajectory": {
                "t": sol.t.tolist(),
                "y": sol.y.tolist()
            }
        }
    
    async def analyze_lorenz_system(self, sigma: float = 10.0, rho: float = 28.0, 
                                  beta: float = 8/3, duration: float = 50.0,
                                  initial_state: Optional[List[float]] = None) -> Dict[str, Any]:
        """
        Analyze the Lorenz system, a classic chaotic system.
        
        dx/dt = sigma * (y - x)
        dy/dt = x * (rho - z) - y
        dz/dt = x * y - beta * z
        
        Args:
            sigma: System parameter sigma
            rho: System parameter rho
            beta: System parameter beta
            duration: Duration of simulation
            initial_state: Initial state [x0, y0, z0], defaults to [1.0, 1.0, 1.0]
            
        Returns:
            Dictionary with analysis results
        """
        logger.info(f"Analyzing Lorenz system with parameters sigma={sigma}, rho={rho}, beta={beta}")
        
        if initial_state is None:
            initial_state = [1.0, 1.0, 1.0]
            
        def lorenz_system(t, state):
            x, y, z = state
            dx_dt = sigma * (y - x)
            dy_dt = x * (rho - z) - y
            dz_dt = x * y - beta * z
            return [dx_dt, dy_dt, dz_dt]
            
        # Integrate the system
        t_span = (0, duration)
        t = np.linspace(t_span[0], t_span[1], int(duration * 100))
        
        sol = sp.integrate.solve_ivp(
            lorenz_system, 
            t_span, 
            initial_state, 
            t_eval=t,
            method='RK45'
        )
        
        # Calculate Lyapunov exponent
        lyapunov_result = await self.calculate_lyapunov_exponent(
            lorenz_system,
            np.array(initial_state),
            t_span,
            perturbation=1e-10,
            dt=0.01
        )
        
        # Create 3D visualization of the attractor
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        ax.plot(sol.y[0], sol.y[1], sol.y[2], 'b-', linewidth=0.5)
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.set_title(f'Lorenz Attractor (σ={sigma}, ρ={rho}, β={beta})')
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/lorenz_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return {
            "parameters": {
                "sigma": sigma,
                "rho": rho,
                "beta": beta
            },
            "initial_state": initial_state,
            "is_chaotic": lyapunov_result["is_chaotic"],
            "lyapunov_exponents": lyapunov_result["lyapunov_exponents"],
            "attractor_plot": filename,
            "trajectory": {
                "t": sol.t.tolist(),
                "x": sol.y[0].tolist(),
                "y": sol.y[1].tolist(),
                "z": sol.y[2].tolist()
            }
        }
        
    async def perform_specialized_task(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Perform a specialized task related to chaos theory
        
        Args:
            task_data: Data needed for the task
            
        Returns:
            Dict containing task results
        """
        logger.info(f"Performing specialized task in {self.specialization}")
        
        task_type = task_data.get("type", "")
        
        if task_type == "logistic_map":
            return await self.analyze_logistic_map(
                r_min=task_data.get("r_min", 2.8),
                r_max=task_data.get("r_max", 4.0),
                n_points=task_data.get("n_points", 1000),
                iterations=task_data.get("iterations", 1000),
                warmup=task_data.get("warmup", 100)
            )
        elif task_type == "lorenz_system":
            return await self.analyze_lorenz_system(
                sigma=task_data.get("sigma", 10.0),
                rho=task_data.get("rho", 28.0),
                beta=task_data.get("beta", 8/3),
                duration=task_data.get("duration", 50.0),
                initial_state=task_data.get("initial_state")
            )
        else:
            return {"error": f"Unknown task type: {task_type}"}
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert agent to dictionary"""
        return {
            "id": self.id,
            "name": self.name,
            "created_at": self.created_at,
            "capabilities": self.capabilities,
            "specialization": self.specialization,
            "running": self.running
        }
        
async def main():
    """Main entry point"""
    agent = ChaosTheoryAnalysisAgent()
    await agent.start()
    
    try:
        # Example: Analyze the logistic map
        logistic_result = await agent.analyze_logistic_map(
            r_min=3.5,
            r_max=4.0,
            n_points=500
        )
        print(f"Logistic map analysis complete. Bifurcation diagram saved to: {logistic_result['diagram_path']}")
        print(f"Chaos onset estimated at r = {logistic_result['chaos_onset']}")
        
        # Example: Analyze the Lorenz system
        lorenz_result = await agent.analyze_lorenz_system()
        print(f"Lorenz system analysis complete. Attractor plot saved to: {lorenz_result['attractor_plot']}")
        print(f"System is chaotic: {lorenz_result['is_chaotic']}")
        print(f"Lyapunov exponents: {lorenz_result['lyapunov_exponents']}")
        
    finally:
        await agent.stop()

if __name__ == "__main__":
    asyncio.run(main())
