#!/usr/bin/env python3
"""
Military Strategy Agent

An agent specialized in military strategy analysis, wargaming, and tactical planning.
This agent can analyze force compositions, simulate engagements, evaluate strategic options,
and provide tactical recommendations based on military doctrine and historical precedents.

Capabilities:
- Strategic analysis
- Tactical planning
- Force modeling
- Logistics planning
- Threat assessment
- Wargame simulation

Generated by Autonomous Agent Creator
"""

import os
import sys
import json
import logging
import asyncio
import uuid
import numpy as np
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
import simpy
from typing import Dict, List, Any, Optional, Tuple, Union, Callable
from datetime import datetime
from pathlib import Path
import random
from collections import defaultdict

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class MilitaryUnit:
    """Represents a military unit with capabilities and attributes"""
    
    def __init__(self, name: str, unit_type: str, strength: int, 
                mobility: float, firepower: float, protection: float,
                supply_consumption: float):
        self.id = str(uuid.uuid4())
        self.name = name
        self.unit_type = unit_type
        self.strength = strength  # Number of personnel/vehicles
        self.mobility = mobility  # Movement capability (0-10)
        self.firepower = firepower  # Combat effectiveness (0-10)
        self.protection = protection  # Defensive capability (0-10)
        self.supply_consumption = supply_consumption  # Resources consumed per day
        self.current_health = 1.0  # Percentage of full strength (0-1)
        self.current_supply = 1.0  # Percentage of full supply (0-1)
        self.position = (0, 0)  # (x, y) coordinates on map
        self.orders = []  # Current orders
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert unit to dictionary"""
        return {
            "id": self.id,
            "name": self.name,
            "type": self.unit_type,
            "strength": self.strength,
            "mobility": self.mobility,
            "firepower": self.firepower,
            "protection": self.protection,
            "supply_consumption": self.supply_consumption,
            "current_health": self.current_health,
            "current_supply": self.current_supply,
            "position": self.position
        }
        
    def combat_effectiveness(self) -> float:
        """Calculate overall combat effectiveness"""
        # Health and supply affect overall effectiveness
        return (self.firepower * 0.4 + self.protection * 0.3 + self.mobility * 0.3) * \
               self.current_health * max(0.5, self.current_supply)
               
    def consume_supplies(self, days: float = 1.0) -> None:
        """Consume supplies based on days of operation"""
        consumption = self.supply_consumption * days
        self.current_supply = max(0.0, self.current_supply - consumption)
        
        # Units without supplies suffer health degradation
        if self.current_supply < 0.2:
            health_loss = 0.05 * days * (1 - self.current_supply * 5)
            self.current_health = max(0.1, self.current_health - health_loss)
            
    def resupply(self, amount: float) -> None:
        """Resupply the unit"""
        self.current_supply = min(1.0, self.current_supply + amount)
        
    def take_damage(self, damage: float) -> None:
        """Take damage from combat or other sources"""
        # Protection reduces damage
        effective_damage = damage / (1 + self.protection / 10)
        self.current_health = max(0.0, self.current_health - effective_damage)
        
    def repair(self, amount: float) -> None:
        """Repair/heal the unit"""
        self.current_health = min(1.0, self.current_health + amount)
        
    def move_to(self, new_position: Tuple[float, float], terrain_factor: float = 1.0) -> float:
        """
        Move unit to new position
        
        Args:
            new_position: Target (x, y) coordinates
            terrain_factor: Modifier for difficult terrain (>1 = harder)
            
        Returns:
            Time taken to move
        """
        current_x, current_y = self.position
        target_x, target_y = new_position
        
        # Calculate distance
        distance = ((target_x - current_x) ** 2 + (target_y - current_y) ** 2) ** 0.5
        
        # Calculate time based on mobility and terrain
        time_taken = distance / (self.mobility / 10) * terrain_factor
        
        # Update position
        self.position = new_position
        
        # Consume supplies based on movement
        self.consume_supplies(time_taken * 0.1)
        
        return time_taken

class Terrain:
    """Represents a terrain map with movement modifiers"""
    
    def __init__(self, width: int, height: int, resolution: float = 1.0):
        self.width = width
        self.height = height
        self.resolution = resolution
        self.terrain_types = {
            "plains": 1.0,
            "forest": 1.5,
            "mountains": 3.0,
            "urban": 2.0,
            "water": 5.0,
            "road": 0.7
        }
        
        # Initialize terrain grid
        self.grid = np.full((height, width), "plains")
        
    def set_terrain(self, x: int, y: int, terrain_type: str) -> None:
        """Set terrain type at position"""
        if 0 <= x < self.width and 0 <= y < self.height:
            if terrain_type in self.terrain_types:
                self.grid[y, x] = terrain_type
                
    def set_region(self, x1: int, y1: int, x2: int, y2: int, terrain_type: str) -> None:
        """Set terrain type for a rectangular region"""
        for x in range(max(0, x1), min(self.width, x2 + 1)):
            for y in range(max(0, y1), min(self.height, y2 + 1)):
                self.set_terrain(x, y, terrain_type)
                
    def get_movement_factor(self, x: int, y: int) -> float:
        """Get movement factor at position"""
        if 0 <= x < self.width and 0 <= y < self.height:
            terrain_type = self.grid[y, x]
            return self.terrain_types.get(terrain_type, 1.0)
        return 1.0
        
    def get_path_cost(self, start: Tuple[int, int], end: Tuple[int, int]) -> float:
        """Calculate movement cost between two points"""
        # Simple implementation - direct path with average terrain cost
        x1, y1 = start
        x2, y2 = end
        
        # Calculate distance
        distance = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5
        
        # Sample points along the path
        num_samples = max(2, int(distance / self.resolution))
        total_factor = 0.0
        
        for i in range(num_samples):
            t = i / (num_samples - 1)
            x = int(x1 + t * (x2 - x1))
            y = int(y1 + t * (y2 - y1))
            total_factor += self.get_movement_factor(x, y)
            
        # Return average movement factor along path
        return (total_factor / num_samples) * distance
        
    def visualize(self, units: Optional[List[MilitaryUnit]] = None) -> str:
        """
        Visualize terrain and units
        
        Returns:
            Path to saved visualization
        """
        # Create color map for terrain types
        color_map = {
            "plains": "lightgreen",
            "forest": "darkgreen",
            "mountains": "brown",
            "urban": "gray",
            "water": "blue",
            "road": "black"
        }
        
        # Create RGB array for visualization
        rgb_data = np.zeros((self.height, self.width, 3), dtype=np.uint8)
        
        for y in range(self.height):
            for x in range(self.width):
                terrain = self.grid[y, x]
                color_name = color_map.get(terrain, "white")
                
                # Convert color name to RGB
                if color_name == "lightgreen":
                    rgb_data[y, x] = [144, 238, 144]
                elif color_name == "darkgreen":
                    rgb_data[y, x] = [0, 100, 0]
                elif color_name == "brown":
                    rgb_data[y, x] = [139, 69, 19]
                elif color_name == "gray":
                    rgb_data[y, x] = [128, 128, 128]
                elif color_name == "blue":
                    rgb_data[y, x] = [0, 0, 255]
                elif color_name == "black":
                    rgb_data[y, x] = [0, 0, 0]
                else:
                    rgb_data[y, x] = [255, 255, 255]
        
        # Create figure
        plt.figure(figsize=(10, 10))
        plt.imshow(rgb_data)
        
        # Plot units if provided
        if units:
            for unit in units:
                x, y = unit.position
                if 0 <= x < self.width and 0 <= y < self.height:
                    # Different markers for different unit types
                    if unit.unit_type == "infantry":
                        marker = 's'  # square
                    elif unit.unit_type == "armor":
                        marker = '^'  # triangle
                    elif unit.unit_type == "artillery":
                        marker = '*'  # star
                    elif unit.unit_type == "air":
                        marker = 'x'  # x
                    else:
                        marker = 'o'  # circle
                        
                    # Size based on strength
                    size = 50 + unit.strength / 10
                    
                    # Color based on side (assuming 'name' contains side info)
                    if "blue" in unit.name.lower():
                        color = 'blue'
                    elif "red" in unit.name.lower():
                        color = 'red'
                    else:
                        color = 'yellow'
                        
                    plt.scatter(x, y, s=size, c=color, marker=marker, 
                               alpha=0.7, edgecolors='black')
                    plt.text(x, y+1, unit.name, fontsize=8, 
                            ha='center', va='bottom')
        
        # Add legend for terrain types
        legend_elements = []
        for terrain, color in color_map.items():
            legend_elements.append(plt.Line2D([0], [0], marker='s', color='w', 
                                  markerfacecolor=color, markersize=10, 
                                  label=terrain.capitalize()))
        
        plt.legend(handles=legend_elements, loc='upper right')
        plt.title('Terrain Map with Units')
        plt.axis('off')
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"terrain_map_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return filename

class SupplyNetwork:
    """Represents a supply network with nodes and connections"""
    
    def __init__(self):
        self.graph = nx.DiGraph()
        self.supply_sources = []
        
    def add_node(self, node_id: str, position: Tuple[float, float], 
                capacity: float, current_supply: float = 0.0) -> None:
        """Add a supply node to the network"""
        self.graph.add_node(node_id, position=position, 
                          capacity=capacity, current_supply=current_supply)
        
    def add_supply_source(self, node_id: str, production_rate: float) -> None:
        """Mark a node as a supply source with production rate"""
        if node_id in self.graph:
            self.graph.nodes[node_id]['is_source'] = True
            self.graph.nodes[node_id]['production_rate'] = production_rate
            self.supply_sources.append(node_id)
        
    def add_connection(self, from_node: str, to_node: str, 
                      capacity: float, vulnerability: float = 0.0) -> None:
        """Add a directed connection between supply nodes"""
        self.graph.add_edge(from_node, to_node, 
                          capacity=capacity, vulnerability=vulnerability,
                          flow=0.0, status=1.0)  # status 1.0 = fully operational
        
    def update_connection_status(self, from_node: str, to_node: str, status: float) -> None:
        """Update the operational status of a connection (0.0-1.0)"""
        if self.graph.has_edge(from_node, to_node):
            self.graph[from_node][to_node]['status'] = max(0.0, min(1.0, status))
            
    def calculate_max_flow(self, source: str, target: str) -> float:
        """Calculate maximum flow from source to target"""
        # Create a copy of the graph with capacities adjusted by status
        flow_graph = nx.DiGraph()
        
        for u, v, data in self.graph.edges(data=True):
            effective_capacity = data['capacity'] * data['status']
            if effective_capacity > 0:
                flow_graph.add_edge(u, v, capacity=effective_capacity)
                
        # Calculate max flow
        try:
            max_flow_value = nx.maximum_flow_value(flow_graph, source, target)
            return max_flow_value
        except nx.NetworkXError:
            return 0.0
            
    def simulate_supply_distribution(self, days: float = 1.0) -> Dict[str, float]:
        """
        Simulate supply distribution through the network
        
        Returns:
            Dictionary of node_id -> supply_received
        """
        # Reset flows
        for u, v in self.graph.edges():
            self.graph[u][v]['flow'] = 0.0
            
        # Generate supplies at sources
        for node_id in self.supply_sources:
            production_rate = self.graph.nodes[node_id].get('production_rate', 0.0)
            current_supply = self.graph.nodes[node_id].get('current_supply', 0.0)
            capacity = self.graph.nodes[node_id].get('capacity', 0.0)
            
            # Add new production
            new_supply = production_rate * days
            self.graph.nodes[node_id]['current_supply'] = min(
                capacity, current_supply + new_supply
            )
            
        # Distribute supplies (simplified algorithm)
        # In a real implementation, this would use a more sophisticated flow algorithm
        supplies_received = defaultdict(float)
        
        # Sort nodes by distance from sources (BFS order)
        for source in self.supply_sources:
            bfs_nodes = list(nx.bfs_tree(self.graph, source))
            
            for node in bfs_nodes:
                # Skip sources
                if node in self.supply_sources:
                    continue
                    
                # Find incoming connections
                incoming_supply = 0.0
                for pred in self.graph.predecessors(node):
                    # Check available supply at predecessor
                    pred_supply = self.graph.nodes[pred].get('current_supply', 0.0)
                    
                    # Check connection capacity
                    edge_data = self.graph[pred][node]
                    edge_capacity = edge_data['capacity'] * edge_data['status'] * days
                    
                    # Calculate flow
                    flow = min(pred_supply, edge_capacity)
                    
                    if flow > 0:
                        # Update predecessor's supply
                        self.graph.nodes[pred]['current_supply'] -= flow
                        
                        # Update edge flow
                        self.graph[pred][node]['flow'] += flow
                        
                        # Add to incoming supply
                        incoming_supply += flow
                
                # Update node's supply
                current_supply = self.graph.nodes[node].get('current_supply', 0.0)
                capacity = self.graph.nodes[node].get('capacity', 0.0)
                
                self.graph.nodes[node]['current_supply'] = min(
                    capacity, current_supply + incoming_supply
                )
                
                supplies_received[node] += incoming_supply
                
        return dict(supplies_received)
        
    def visualize(self) -> str:
        """
        Visualize the supply network
        
        Returns:
            Path to saved visualization
        """
        plt.figure(figsize=(12, 10))
        
        # Get node positions
        pos = nx.spring_layout(self.graph)
        
        # Draw nodes
        source_nodes = [n for n in self.graph.nodes() if n in self.supply_sources]
        other_nodes = [n for n in self.graph.nodes() if n not in self.supply_sources]
        
        # Draw sources as squares
        nx.draw_networkx_nodes(self.graph, pos, nodelist=source_nodes, 
                              node_color='green', node_shape='s', node_size=500)
        
        # Draw other nodes as circles
        nx.draw_networkx_nodes(self.graph, pos, nodelist=other_nodes, 
                              node_color='lightblue', node_shape='o', node_size=300)
        
        # Draw edges with width based on capacity
        for u, v, data in self.graph.edges(data=True):
            width = data['capacity'] / 10  # Scale for visualization
            status = data['status']
            
            # Color based on status
            if status > 0.8:
                color = 'green'
            elif status > 0.4:
                color = 'orange'
            else:
                color = 'red'
                
            # Draw the edge
            nx.draw_networkx_edges(self.graph, pos, edgelist=[(u, v)], 
                                  width=width, edge_color=color, arrows=True)
        
        # Add labels
        labels = {}
        for node in self.graph.nodes():
            supply = self.graph.nodes[node].get('current_supply', 0)
            capacity = self.graph.nodes[node].get('capacity', 0)
            labels[node] = f"{node}\n{supply:.1f}/{capacity:.1f}"
            
        nx.draw_networkx_labels(self.graph, pos, labels=labels, font_size=8)
        
        # Add a title
        plt.title('Supply Network')
        plt.axis('off')
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"supply_network_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return filename

class CombatModel:
    """Models combat interactions between military units"""
    
    @staticmethod
    def resolve_combat(attacker: MilitaryUnit, defender: MilitaryUnit, 
                      terrain_factor: float = 1.0, surprise: float = 0.0) -> Dict[str, Any]:
        """
        Resolve combat between two units
        
        Args:
            attacker: Attacking unit
            defender: Defending unit
            terrain_factor: Terrain modifier (>1 favors defender)
            surprise: Surprise factor (0-1, higher values favor attacker)
            
        Returns:
            Dictionary with combat results
        """
        # Calculate base combat power
        attacker_power = attacker.combat_effectiveness() * attacker.strength
        defender_power = defender.combat_effectiveness() * defender.strength * terrain_factor
        
        # Apply surprise modifier
        attacker_power *= (1 + surprise)
        
        # Calculate damage
        attacker_damage_dealt = attacker_power / (defender_power + 10)
        defender_damage_dealt = defender_power / (attacker_power + 20)
        
        # Apply damage
        attacker.take_damage(defender_damage_dealt)
        defender.take_damage(attacker_damage_dealt)
        
        # Consume supplies
        attacker.consume_supplies(0.2)  # Combat consumes extra supplies
        defender.consume_supplies(0.1)
        
        # Determine outcome
        attacker_remaining = attacker.current_health
        defender_remaining = defender.current_health
        
        if defender_remaining <= 0.1 and attacker_remaining > 0.2:
            outcome = "attacker_victory"
        elif attacker_remaining <= 0.1 and defender_remaining > 0.2:
            outcome = "defender_victory"
        elif attacker_remaining <= 0.1 and defender_remaining <= 0.1:
            outcome = "mutual_destruction"
        else:
            # Compare remaining strength
            if attacker_damage_dealt > defender_damage_dealt * 1.5:
                outcome = "attacker_advantage"
            elif defender_damage_dealt > attacker_damage_dealt * 1.5:
                outcome = "defender_advantage"
            else:
                outcome = "stalemate"
                
        return {
            "outcome": outcome,
            "attacker_damage_taken": defender_damage_dealt,
            "defender_damage_taken": attacker_damage_dealt,
            "attacker_remaining": attacker_remaining,
            "defender_remaining": defender_remaining
        }
    
    @staticmethod
    def resolve_group_combat(attackers: List[MilitaryUnit], defenders: List[MilitaryUnit],
                           terrain_factor: float = 1.0, surprise: float = 0.0) -> Dict[str, Any]:
        """
        Resolve combat between groups of units
        
        Args:
            attackers: List of attacking units
            defenders: List of defending units
            terrain_factor: Terrain modifier
            surprise: Surprise factor
            
        Returns:
            Dictionary with combat results
        """
        # Calculate initial strengths
        initial_attacker_strength = sum(unit.combat_effectiveness() * unit.strength 
                                      for unit in attackers)
        initial_defender_strength = sum(unit.combat_effectiveness() * unit.strength 
                                      for unit in defenders)
        
        # Track casualties
        attacker_casualties = []
        defender_casualties = []
        
        # Distribute combat
        # This is a simplified model - a real model would be more sophisticated
        for attacker in attackers:
            # Skip destroyed units
            if attacker.current_health <= 0.1:
                continue
                
            # Find target
            defenders_alive = [d for d in defenders if d.current_health > 0.1]
            if not defenders_alive:
                break
                
            # Simple targeting - pick unit with highest combat effectiveness
            target = max(defenders_alive, key=lambda d: d.combat_effectiveness())
            
            # Resolve individual combat
            result = CombatModel.resolve_combat(attacker, target, terrain_factor, surprise)
            
            # Track casualties
            if target.current_health <= 0.1 and target not in defender_casualties:
                defender_casualties.append(target)
                
            if attacker.current_health <= 0.1 and attacker not in attacker_casualties:
                attacker_casualties.append(attacker)
        
        # Calculate remaining strengths
        remaining_attacker_strength = sum(unit.combat_effectiveness() * unit.strength 
                                        for unit in attackers 
                                        if unit.current_health > 0.1)
        remaining_defender_strength = sum(unit.combat_effectiveness() * unit.strength 
                                        for unit in defenders
                                        if unit.current_health > 0.1)
        
        # Determine outcome
        if remaining_defender_strength <= 0.1 * initial_defender_strength and remaining_attacker_strength > 0.3 * initial_attacker_strength:
            outcome = "attacker_decisive_victory"
        elif remaining_attacker_strength <= 0.1 * initial_attacker_strength and remaining_defender_strength > 0.3 * initial_defender_strength:
            outcome = "defender_decisive_victory"
        elif remaining_defender_strength <= 0.3 * initial_defender_strength and remaining_attacker_strength > 0.5 * initial_attacker_strength:
            outcome = "attacker_victory"
        elif remaining_attacker_strength <= 0.3 * initial_attacker_strength and remaining_defender_strength > 0.5 * initial_defender_strength:
            outcome = "defender_victory"
        elif remaining_attacker_strength <= 0.3 * initial_attacker_strength and remaining_defender_strength <= 0.3 * initial_defender_strength:
            outcome = "pyrrhic_victory"
        else:
            outcome = "stalemate"
            
        return {
            "outcome": outcome,
            "initial_attacker_strength": initial_attacker_strength,
            "initial_defender_strength": initial_defender_strength,
            "remaining_attacker_strength": remaining_attacker_strength,
            "remaining_defender_strength": remaining_defender_strength,
            "attacker_casualties": len(attacker_casualties),
            "defender_casualties": len(defender_casualties),
            "attacker_casualty_ratio": len(attacker_casualties) / len(attackers) if attackers else 0,
            "defender_casualty_ratio": len(defender_casualties) / len(defenders) if defenders else 0
        }

class MilitaryStrategyAgent:
    """
    An agent specialized in military strategy analysis, wargaming, and tactical planning.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.id = str(uuid.uuid4())
        self.name = "Military Strategy Agent"
        self.created_at = datetime.now().isoformat()
        self.config = config or {}
        self.capabilities = ["strategic_analysis", "tactical_planning", 
                            "force_modeling", "logistics_planning", 
                            "threat_assessment", "wargame_simulation"]
        self.specialization = "military_strategy"
        self.running = False
        self.results_dir = self.config.get("results_dir", "./strategy_results")
        os.makedirs(self.results_dir, exist_ok=True)
        
        # Initialize components
        self.units = {}
        self.terrain = None
        self.supply_network = None
        
        logger.info(f"Initialized {self.name} agent with ID {self.id}")
        
    async def start(self):
        """Start the agent"""
        self.running = True
        logger.info(f"Started {self.name} agent")
        
    async def stop(self):
        """Stop the agent"""
        self.running = False
        logger.info(f"Stopped {self.name} agent")
        
    async def run(self):
        """Main execution loop"""
        self.running = True
        try:
            while self.running:
                # Main agent logic here
                await self._process_cycle()
                await asyncio.sleep(1)  # Prevent CPU hogging
        except Exception as e:
            logger.error(f"Error in agent execution: {e}")
            self.running = False
        finally:
            logger.info(f"Agent {self.name} execution completed")
            
    async def _process_cycle(self):
        """Process a single execution cycle"""
        # Implement the core agent logic here
        pass
    
    def create_unit(self, name: str, unit_type: str, strength: int, 
                   mobility: float, firepower: float, protection: float,
                   supply_consumption: float) -> MilitaryUnit:
        """Create a new military unit"""
        unit = MilitaryUnit(
            name=name,
            unit_type=unit_type,
            strength=strength,
            mobility=mobility,
            firepower=firepower,
            protection=protection,
            supply_consumption=supply_consumption
        )
        self.units[unit.id] = unit
        return unit
        
    def create_terrain(self, width: int, height: int) -> Terrain:
        """Create a new terrain map"""
        self.terrain = Terrain(width, height)
        return self.terrain
        
    def create_supply_network(self) -> SupplyNetwork:
        """Create a new supply network"""
        self.supply_network = SupplyNetwork()
        return self.supply_network
        
    async def analyze_force_balance(self, blue_forces: List[MilitaryUnit], 
                                  red_forces: List[MilitaryUnit]) -> Dict[str, Any]:
        """
        Analyze the balance of forces between two sides
        
        Args:
            blue_forces: List of friendly units
            red_forces: List of enemy units
            
        Returns:
            Dictionary with analysis results
        """
        logger.info(f"Analyzing force balance between {len(blue_forces)} blue units and {len(red_forces)} red units")
        
        # Calculate total combat power
        blue_power = sum(unit.combat_effectiveness() * unit.strength for unit in blue_forces)
        red_power = sum(unit.combat_effectiveness() * unit.strength for unit in red_forces)
        
        # Calculate power by unit type
        blue_power_by_type = {}
        red_power_by_type = {}
        
        for unit in blue_forces:
            blue_power_by_type[unit.unit_type] = blue_power_by_type.get(unit.unit_type, 0) + \
                                               unit.combat_effectiveness() * unit.strength
                                               
        for unit in red_forces:
            red_power_by_type[unit.unit_type] = red_power_by_type.get(unit.unit_type, 0) + \
                                              unit.combat_effectiveness() * unit.strength
        
        # Calculate force ratios
        overall_ratio = blue_power / red_power if red_power > 0 else float('inf')
        
        type_ratios = {}
        all_types = set(blue_power_by_type.keys()) | set(red_power_by_type.keys())
        
        for unit_type in all_types:
            blue_type_power = blue_power_by_type.get(unit_type, 0)
            red_type_power = red_power_by_type.get(unit_type, 0)
            
            if red_type_power > 0:
                type_ratios[unit_type] = blue_type_power / red_type_power
            else:
                type_ratios[unit_type] = float('inf')
        
        # Create visualization
        plt.figure(figsize=(12, 8))
        
        # Bar chart of force composition
        plt.subplot(2, 2, 1)
        blue_composition = [blue_power_by_type.get(t, 0) for t in all_types]
        red_composition = [red_power_by_type.get(t, 0) for t in all_types]
        
        x = np.arange(len(all_types))
        width = 0.35
        
        plt.bar(x - width/2, blue_composition, width, label='Blue Forces')
        plt.bar(x + width/2, red_composition, width, label='Red Forces')
        
        plt.xlabel('Unit Type')
        plt.ylabel('Combat Power')
        plt.title('Force Composition')
        plt.xticks(x, all_types)
        plt.legend()
        
        # Pie chart of overall balance
        plt.subplot(2, 2, 2)
        plt.pie([blue_power, red_power], labels=['Blue', 'Red'], 
               autopct='%1.1f%%', colors=['blue', 'red'])
        plt.title('Overall Force Balance')
        
        # Bar chart of force ratios
        plt.subplot(2, 2, 3)
        ratio_values = [min(5, type_ratios.get(t, 0)) for t in all_types]  # Cap at 5 for visualization
        
        plt.bar(x, ratio_values, width)
        plt.axhline(y=1.0, color='r', linestyle='-')
        
        plt.xlabel('Unit Type')
        plt.ylabel('Blue:Red Ratio')
        plt.title('Force Ratios by Type')
        plt.xticks(x, all_types)
        
        # Text summary
        plt.subplot(2, 2, 4)
        plt.axis('off')
        
        summary_text = f"Overall Force Ratio: {overall_ratio:.2f}\n\n"
        summary_text += "Force Ratios by Type:\n"
        
        for unit_type, ratio in type_ratios.items():
            summary_text += f"  {unit_type}: {ratio:.2f}\n"
            
        advantage = "Blue" if overall_ratio > 1.2 else "Red" if overall_ratio < 0.8 else "Neither"
        summary_text += f"\nAdvantage: {advantage}"
        
        plt.text(0, 0.5, summary_text, fontsize=10, verticalalignment='center')
        
        plt.tight_layout()
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/force_balance_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return {
            "blue_power": blue_power,
            "red_power": red_power,
            "overall_ratio": overall_ratio,
            "blue_composition": blue_power_by_type,
            "red_composition": red_power_by_type,
            "type_ratios": type_ratios,
            "advantage": advantage,
            "visualization": filename
        }
    
    async def simulate_engagement(self, blue_forces: List[MilitaryUnit], 
                                red_forces: List[MilitaryUnit],
                                terrain_factor: float = 1.0,
                                surprise: float = 0.0) -> Dict[str, Any]:
        """
        Simulate a military engagement between two forces
        
        Args:
            blue_forces: List of friendly units
            red_forces: List of enemy units
            terrain_factor: Terrain modifier (>1 favors defender)
            surprise: Surprise factor (0-1, higher values favor attacker)
            
        Returns:
            Dictionary with simulation results
        """
        logger.info(f"Simulating engagement between {len(blue_forces)} blue units and {len(red_forces)} red units")
        
        # Create copies of units to avoid modifying originals
        blue_copies = []
        for unit in blue_forces:
            copy = MilitaryUnit(
                name=unit.name,
                unit_type=unit.unit_type,
                strength=unit.strength,
                mobility=unit.mobility,
                firepower=unit.firepower,
                protection=unit.protection,
                supply_consumption=unit.supply_consumption
            )
            copy.current_health = unit.current_health
            copy.current_supply = unit.current_supply
            copy.position = unit.position
            blue_copies.append(copy)
            
        red_copies = []
        for unit in red_forces:
            copy = MilitaryUnit(
                name=unit.name,
                unit_type=unit.unit_type,
                strength=unit.strength,
                mobility=unit.mobility,
                firepower=unit.firepower,
                protection=unit.protection,
                supply_consumption=unit.supply_consumption
            )
            copy.current_health = unit.current_health
            copy.current_supply = unit.current_supply
            copy.position = unit.position
            red_copies.append(copy)
        
        # Simulate combat
        combat_result = CombatModel.resolve_group_combat(
            attackers=blue_copies,
            defenders=red_copies,
            terrain_factor=terrain_factor,
            surprise=surprise
        )
        
        # Track unit status after combat
        blue_status = []
        for i, unit in enumerate(blue_copies):
            blue_status.append({
                "name": unit.name,
                "type": unit.unit_type,
                "initial_health": blue_forces[i].current_health,
                "final_health": unit.current_health,
                "initial_supply": blue_forces[i].current_supply,
                "final_supply": unit.current_supply
            })
            
        red_status = []
        for i, unit in enumerate(red_copies):
            red_status.append({
                "name": unit.name,
                "type": unit.unit_type,
                "initial_health": red_forces[i].current_health,
                "final_health": unit.current_health,
                "initial_supply": red_forces[i].current_supply,
                "final_supply": unit.current_supply
            })
        
        # Create visualization
        plt.figure(figsize=(12, 8))
        
        # Bar chart of before/after strength
        plt.subplot(2, 2, 1)
        
        initial_blue = combat_result["initial_attacker_strength"]
        final_blue = combat_result["remaining_attacker_strength"]
        initial_red = combat_result["initial_defender_strength"]
        final_red = combat_result["remaining_defender_strength"]
        
        plt.bar([0, 1], [initial_blue, final_blue], width=0.4, color=['blue', 'lightblue'])
        plt.bar([2, 3], [initial_red, final_red], width=0.4, color=['red', 'lightcoral'])
        
        plt.xticks([0.5, 2.5], ['Blue Forces', 'Red Forces'])
        plt.ylabel('Combat Strength')
        plt.title('Force Strength Before and After')
        
        # Pie chart of casualties
        plt.subplot(2, 2, 2)
        
        blue_casualties = combat_result["attacker_casualties"]
        blue_survivors = len(blue_forces) - blue_casualties
        red_casualties = combat_result["defender_casualties"]
        red_survivors = len(red_forces) - red_casualties
        
        plt.pie([blue_survivors, blue_casualties, red_survivors, red_casualties],
               labels=['Blue Survivors', 'Blue Casualties', 'Red Survivors', 'Red Casualties'],
               colors=['blue', 'lightblue', 'red', 'lightcoral'])
        plt.title('Casualties')
        
        # Unit health changes
        plt.subplot(2, 2, 3)
        
        # Get top 5 units from each side for visualization
        top_blue = sorted(blue_status, key=lambda x: x["initial_health"] - x["final_health"], reverse=True)[:5]
        top_red = sorted(red_status, key=lambda x: x["initial_health"] - x["final_health"], reverse=True)[:5]
        
        blue_names = [u["name"] for u in top_blue]
        blue_damage = [u["initial_health"] - u["final_health"] for u in top_blue]
        
        red_names = [u["name"] for u in top_red]
        red_damage = [u["initial_health"] - u["final_health"] for u in top_red]
        
        y_pos = np.arange(len(blue_names + red_names))
        
        plt.barh(y_pos[:len(blue_names)], blue_damage, color='blue')
        plt.barh(y_pos[len(blue_names):], red_damage, color='red')
        
        plt.yticks(y_pos, blue_names + red_names)
        plt.xlabel('Damage Taken')
        plt.title('Top Units Damage')
        
        # Text summary
        plt.subplot(2, 2, 4)
        plt.axis('off')
        
        summary_text = f"Outcome: {combat_result['outcome'].replace('_', ' ').title()}\n\n"
        summary_text += f"Blue Forces:\n"
        summary_text += f"  Initial Strength: {initial_blue:.1f}\n"
        summary_text += f"  Final Strength: {final_blue:.1f}\n"
        summary_text += f"  Casualties: {blue_casualties}/{len(blue_forces)}\n\n"
        
        summary_text += f"Red Forces:\n"
        summary_text += f"  Initial Strength: {initial_red:.1f}\n"
        summary_text += f"  Final Strength: {final_red:.1f}\n"
        summary_text += f"  Casualties: {red_casualties}/{len(red_forces)}\n"
        
        plt.text(0, 0.5, summary_text, fontsize=10, verticalalignment='center')
        
        plt.tight_layout()
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/engagement_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return {
            "combat_result": combat_result,
            "blue_status": blue_status,
            "red_status": red_status,
            "visualization": filename
        }
    
    async def analyze_logistics(self, units: List[MilitaryUnit], 
                              supply_network: SupplyNetwork,
                              days: int = 30) -> Dict[str, Any]:
        """
        Analyze logistics and supply for a force over time
        
        Args:
            units: List of units to analyze
            supply_network: Supply network to use
            days: Number of days to simulate
            
        Returns:
            Dictionary with logistics analysis
        """
        logger.info(f"Analyzing logistics for {len(units)} units over {days} days")
        
        # Create copies of units and supply network
        unit_copies = []
        for unit in units:
            copy = MilitaryUnit(
                name=unit.name,
                unit_type=unit.unit_type,
                strength=unit.strength,
                mobility=unit.mobility,
                firepower=unit.firepower,
                protection=unit.protection,
                supply_consumption=unit.supply_consumption
            )
            copy.current_health = unit.current_health
            copy.current_supply = unit.current_supply
            copy.position = unit.position
            unit_copies.append(copy)
        
        # Track supply levels over time
        supply_levels = []
        health_levels = []
        combat_effectiveness = []
        
        # Simulate each day
        for day in range(days):
            # Distribute supplies
            supply_network.simulate_supply_distribution(1.0)
            
            # Track supply levels
            day_supplies = []
            day_health = []
            day_effectiveness = []
            
            for unit in unit_copies:
                # Consume supplies
                unit.consume_supplies(1.0)
                
                # Track metrics
                day_supplies.append(unit.current_supply)
                day_health.append(unit.current_health)
                day_effectiveness.append(unit.combat_effectiveness())
                
            supply_levels.append(day_supplies)
            health_levels.append(day_health)
            combat_effectiveness.append(day_effectiveness)
        
        # Calculate averages
        avg_supplies = [sum(day) / len(day) for day in supply_levels]
        avg_health = [sum(day) / len(day) for day in health_levels]
        avg_effectiveness = [sum(day) / len(day) for day in combat_effectiveness]
        
        # Find critical points
        critical_day = -1
        for day, avg_supply in enumerate(avg_supplies):
            if avg_supply < 0.3:  # Critical supply threshold
                critical_day = day
                break
                
        # Create visualization
        plt.figure(figsize=(12, 8))
        
        # Plot average supply levels
        plt.subplot(2, 2, 1)
        plt.plot(range(days), avg_supplies)
        plt.axhline(y=0.3, color='r', linestyle='--')  # Critical threshold
        plt.xlabel('Day')
        plt.ylabel('Average Supply Level')
        plt.title('Supply Levels Over Time')
        
        # Plot average health
        plt.subplot(2, 2, 2)
        plt.plot(range(days), avg_health)
        plt.xlabel('Day')
        plt.ylabel('Average Health')
        plt.title('Unit Health Over Time')
        
        # Plot combat effectiveness
        plt.subplot(2, 2, 3)
        plt.plot(range(days), avg_effectiveness)
        plt.xlabel('Day')
        plt.ylabel('Average Combat Effectiveness')
        plt.title('Combat Effectiveness Over Time')
        
        # Text summary
        plt.subplot(2, 2, 4)
        plt.axis('off')
        
        summary_text = f"Logistics Analysis ({days} days):\n\n"
        
        if critical_day >= 0:
            summary_text += f"Critical supply shortage on day {critical_day}\n\n"
        else:
            summary_text += f"No critical supply shortage detected\n\n"
            
        initial_effectiveness = avg_effectiveness[0]
        final_effectiveness = avg_effectiveness[-1]
        
        summary_text += f"Initial combat effectiveness: {initial_effectiveness:.2f}\n"
        summary_text += f"Final combat effectiveness: {final_effectiveness:.2f}\n"
        summary_text += f"Change: {(final_effectiveness - initial_effectiveness) / initial_effectiveness * 100:.1f}%\n\n"
        
        if final_effectiveness < 0.5 * initial_effectiveness:
            summary_text += "WARNING: Severe degradation in combat effectiveness"
        elif final_effectiveness < 0.8 * initial_effectiveness:
            summary_text += "CAUTION: Significant degradation in combat effectiveness"
        else:
            summary_text += "Force maintains acceptable combat effectiveness"
            
        plt.text(0, 0.5, summary_text, fontsize=10, verticalalignment='center')
        
        plt.tight_layout()
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/logistics_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return {
            "days_simulated": days,
            "critical_day": critical_day if critical_day >= 0 else None,
            "initial_effectiveness": initial_effectiveness,
            "final_effectiveness": final_effectiveness,
            "effectiveness_change": (final_effectiveness - initial_effectiveness) / initial_effectiveness,
            "avg_supplies": avg_supplies,
            "avg_health": avg_health,
            "avg_effectiveness": avg_effectiveness,
            "visualization": filename
        }
        
    async def perform_specialized_task(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Perform a specialized task related to military strategy
        
        Args:
            task_data: Data needed for the task
            
        Returns:
            Dict containing task results
        """
        logger.info(f"Performing specialized task in {self.specialization}")
        
        task_type = task_data.get("type", "")
        
        if task_type == "force_balance":
            # Create units from task data
            blue_forces = []
            for unit_data in task_data.get("blue_forces", []):
                unit = MilitaryUnit(
                    name=unit_data.get("name", "Blue Unit"),
                    unit_type=unit_data.get("type", "infantry"),
                    strength=unit_data.get("strength", 100),
                    mobility=unit_data.get("mobility", 5.0),
                    firepower=unit_data.get("firepower", 5.0),
                    protection=unit_data.get("protection", 5.0),
                    supply_consumption=unit_data.get("supply_consumption", 0.1)
                )
                blue_forces.append(unit)
                
            red_forces = []
            for unit_data in task_data.get("red_forces", []):
                unit = MilitaryUnit(
                    name=unit_data.get("name", "Red Unit"),
                    unit_type=unit_data.get("type", "infantry"),
                    strength=unit_data.get("strength", 100),
                    mobility=unit_data.get("mobility", 5.0),
                    firepower=unit_data.get("firepower", 5.0),
                    protection=unit_data.get("protection", 5.0),
                    supply_consumption=unit_data.get("supply_consumption", 0.1)
                )
                red_forces.append(unit)
                
            return await self.analyze_force_balance(blue_forces, red_forces)
            
        elif task_type == "engagement":
            # Create units from task data
            blue_forces = []
            for unit_data in task_data.get("blue_forces", []):
                unit = MilitaryUnit(
                    name=unit_data.get("name", "Blue Unit"),
                    unit_type=unit_data.get("type", "infantry"),
                    strength=unit_data.get("strength", 100),
                    mobility=unit_data.get("mobility", 5.0),
                    firepower=unit_data.get("firepower", 5.0),
                    protection=unit_data.get("protection", 5.0),
                    supply_consumption=unit_data.get("supply_consumption", 0.1)
                )
                blue_forces.append(unit)
                
            red_forces = []
            for unit_data in task_data.get("red_forces", []):
                unit = MilitaryUnit(
                    name=unit_data.get("name", "Red Unit"),
                    unit_type=unit_data.get("type", "infantry"),
                    strength=unit_data.get("strength", 100),
                    mobility=unit_data.get("mobility", 5.0),
                    firepower=unit_data.get("firepower", 5.0),
                    protection=unit_data.get("protection", 5.0),
                    supply_consumption=unit_data.get("supply_consumption", 0.1)
                )
                red_forces.append(unit)
                
            return await self.simulate_engagement(
                blue_forces=blue_forces,
                red_forces=red_forces,
                terrain_factor=task_data.get("terrain_factor", 1.0),
                surprise=task_data.get("surprise", 0.0)
            )
            
        else:
            return {"error": f"Unknown task type: {task_type}"}
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert agent to dictionary"""
        return {
            "id": self.id,
            "name": self.name,
            "created_at": self.created_at,
            "capabilities": self.capabilities,
            "specialization": self.specialization,
            "running": self.running
        }
        
async def main():
    """Main entry point"""
    agent = MilitaryStrategyAgent()
    await agent.start()
    
    try:
        # Create example units
        blue_infantry = agent.create_unit(
            name="Blue Infantry Company",
            unit_type="infantry",
            strength=150,
            mobility=5.0,
            firepower=6.0,
            protection=4.0,
            supply_consumption=0.1
        )
        
        blue_armor = agent.create_unit(
            name="Blue Armor Platoon",
            unit_type="armor",
            strength=50,
            mobility=7.0,
            firepower=9.0,
            protection=8.0,
            supply_consumption=0.3
        )
        
        red_infantry1 = agent.create_unit(
            name="Red Infantry Battalion",
            unit_type="infantry",
            strength=300,
            mobility=4.0,
            firepower=5.0,
            protection=3.0,
            supply_consumption=0.1
        )
        
        red_artillery = agent.create_unit(
            name="Red Artillery Battery",
            unit_type="artillery",
            strength=40,
            mobility=3.0,
            firepower=8.0,
            protection=2.0,
            supply_consumption=0.2
        )
        
        # Analyze force balance
        balance_result = await agent.analyze_force_balance(
            blue_forces=[blue_infantry, blue_armor],
            red_forces=[red_infantry1, red_artillery]
        )
        
        print(f"Force balance analysis complete. Visualization saved to: {balance_result['visualization']}")
        print(f"Overall force ratio: {balance_result['overall_ratio']:.2f}")
        print(f"Advantage: {balance_result['advantage']}")
        
        # Simulate engagement
        engagement_result = await agent.simulate_engagement(
            blue_forces=[blue_infantry, blue_armor],
            red_forces=[red_infantry1, red_artillery],
            terrain_factor=1.2,  # Slightly favors defender
            surprise=0.3  # Some surprise factor
        )
        
        print(f"Engagement simulation complete. Visualization saved to: {engagement_result['visualization']}")
        print(f"Outcome: {engagement_result['combat_result']['outcome'].replace('_', ' ').title()}")
        
    finally:
        await agent.stop()

if __name__ == "__main__":
    asyncio.run(main())
