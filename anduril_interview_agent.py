#!/usr/bin/env python3
"""
Anduril Interview Preparation Agent

An agent specialized in preparing candidates for Anduril Industries interviews with focus on defense technology and engineering challenges.
This agent provides technical interview preparation, defense technology knowledge, system design guidance, algorithm coaching, and behavioral interview preparation.

Capabilities:
- Technical interview preparation
- Defense technology knowledge
- System design
- Algorithm coaching
- Behavioral interview prep
- Autonomous systems knowledge

Generated by Autonomous Agent Creator
"""

import os
import sys
import json
import logging
import asyncio
import uuid
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import random
from typing import Dict, List, Any, Optional, Tuple, Union, Callable
from datetime import datetime
from pathlib import Path
import re

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class InterviewQuestion:
    """Represents an interview question with metadata and sample answers"""
    
    def __init__(self, question: str, category: str, difficulty: str, 
                tags: List[str], sample_answer: str, 
                follow_ups: Optional[List[str]] = None):
        self.id = str(uuid.uuid4())
        self.question = question
        self.category = category
        self.difficulty = difficulty
        self.tags = tags or []
        self.sample_answer = sample_answer
        self.follow_ups = follow_ups or []
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert question to dictionary"""
        return {
            "id": self.id,
            "question": self.question,
            "category": self.category,
            "difficulty": self.difficulty,
            "tags": self.tags,
            "sample_answer": self.sample_answer,
            "follow_ups": self.follow_ups
        }
        
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'InterviewQuestion':
        """Create question from dictionary"""
        question = cls(
            question=data["question"],
            category=data["category"],
            difficulty=data["difficulty"],
            tags=data["tags"],
            sample_answer=data["sample_answer"],
            follow_ups=data.get("follow_ups", [])
        )
        if "id" in data:
            question.id = data["id"]
        return question

class InterviewPreparationPlan:
    """Represents a personalized interview preparation plan"""
    
    def __init__(self, candidate_name: str, position: str, 
                experience_level: str, focus_areas: List[str]):
        self.id = str(uuid.uuid4())
        self.candidate_name = candidate_name
        self.position = position
        self.experience_level = experience_level
        self.focus_areas = focus_areas
        self.created_at = datetime.now().isoformat()
        self.sections: List[Dict[str, Any]] = []
        self.resources: List[Dict[str, str]] = []
        
    def add_section(self, title: str, description: str, 
                   questions: List[InterviewQuestion],
                   estimated_hours: float) -> None:
        """Add a section to the preparation plan"""
        self.sections.append({
            "title": title,
            "description": description,
            "questions": [q.to_dict() for q in questions],
            "estimated_hours": estimated_hours
        })
        
    def add_resource(self, title: str, url: str, type: str) -> None:
        """Add a resource to the preparation plan"""
        self.resources.append({
            "title": title,
            "url": url,
            "type": type
        })
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert plan to dictionary"""
        return {
            "id": self.id,
            "candidate_name": self.candidate_name,
            "position": self.position,
            "experience_level": self.experience_level,
            "focus_areas": self.focus_areas,
            "created_at": self.created_at,
            "sections": self.sections,
            "resources": self.resources
        }
        
    def total_hours(self) -> float:
        """Calculate total estimated hours for the plan"""
        return sum(section["estimated_hours"] for section in self.sections)
        
    def generate_schedule(self, days: int) -> List[Dict[str, Any]]:
        """Generate a daily schedule for the preparation plan"""
        total_hours = self.total_hours()
        hours_per_day = total_hours / days
        
        # Create a list of all questions from all sections
        all_questions = []
        for section in self.sections:
            for question in section["questions"]:
                all_questions.append({
                    "question": question,
                    "section": section["title"]
                })
                
        # Shuffle questions to distribute them across days
        random.shuffle(all_questions)
        
        # Distribute questions across days
        schedule = []
        questions_per_day = len(all_questions) // days
        remainder = len(all_questions) % days
        
        start_idx = 0
        for day in range(days):
            # Calculate number of questions for this day
            day_questions = questions_per_day
            if day < remainder:
                day_questions += 1
                
            # Get questions for this day
            day_range = all_questions[start_idx:start_idx + day_questions]
            start_idx += day_questions
            
            # Group by section
            sections = {}
            for item in day_range:
                section = item["section"]
                if section not in sections:
                    sections[section] = []
                sections[section].append(item["question"])
                
            # Create day schedule
            day_schedule = {
                "day": day + 1,
                "sections": [
                    {
                        "title": section,
                        "questions": questions
                    }
                    for section, questions in sections.items()
                ],
                "estimated_hours": hours_per_day
            }
            
            schedule.append(day_schedule)
            
        return schedule

class AndurilInterviewPreparationAgent:
    """
    An agent specialized in preparing candidates for Anduril Industries interviews with focus on defense technology and engineering challenges.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.id = str(uuid.uuid4())
        self.name = "Anduril Interview Preparation Agent"
        self.created_at = datetime.now().isoformat()
        self.config = config or {}
        self.capabilities = ["technical_interview_prep", "defense_technology_knowledge", 
                            "system_design", "algorithm_coaching", 
                            "behavioral_interview_prep", "autonomous_systems_knowledge"]
        self.specialization = "anduril_interview"
        self.running = False
        self.results_dir = self.config.get("results_dir", "./interview_prep_results")
        os.makedirs(self.results_dir, exist_ok=True)
        
        # Load question database
        self.questions: Dict[str, InterviewQuestion] = {}
        self._initialize_question_database()
        
        logger.info(f"Initialized {self.name} agent with ID {self.id}")
        
    def _initialize_question_database(self):
        """Initialize the question database with sample questions"""
        # Technical questions
        self._add_question(
            question="Explain how a convolutional neural network works and how it might be applied to drone vision systems.",
            category="Technical",
            difficulty="Hard",
            tags=["machine_learning", "computer_vision", "autonomous_systems"],
            sample_answer="A CNN consists of convolutional layers that apply filters to detect features, pooling layers to reduce dimensionality, and fully connected layers for classification. In drone vision systems, CNNs can be used for object detection, obstacle avoidance, terrain classification, and target recognition. The key challenges include real-time processing constraints, handling varying lighting conditions, and maintaining accuracy with limited computational resources onboard the drone.",
            follow_ups=[
                "How would you optimize a CNN for real-time processing on an edge device?",
                "What techniques would you use to make the vision system robust to adverse weather conditions?"
            ]
        )
        
        self._add_question(
            question="Design a distributed system for processing and analyzing data from multiple autonomous drones operating in a contested environment.",
            category="System Design",
            difficulty="Hard",
            tags=["distributed_systems", "autonomous_systems", "defense_technology"],
            sample_answer="The system would consist of: 1) Edge processing on each drone for time-critical functions, 2) Mesh networking between drones for resilient communication, 3) Secure data transmission protocols with encryption and authentication, 4) Distributed database with eventual consistency for mission data, 5) Central command node with failover capabilities, 6) Redundant processing nodes for analytics, and 7) Graceful degradation mechanisms when communication is disrupted. Key considerations include minimizing bandwidth requirements, ensuring security against adversarial attacks, maintaining operation during communication blackouts, and optimizing for power constraints.",
            follow_ups=[
                "How would you handle a situation where a drone loses connection with the rest of the system?",
                "What security measures would you implement to prevent data interception or tampering?"
            ]
        )
        
        self._add_question(
            question="Implement an algorithm to efficiently detect and track multiple moving objects in a video stream.",
            category="Algorithms",
            difficulty="Medium",
            tags=["computer_vision", "algorithms", "real_time_processing"],
            sample_answer="I would implement a multi-stage pipeline: 1) Background subtraction to identify moving objects, 2) Contour detection to isolate distinct objects, 3) Feature extraction (e.g., using SIFT or ORB) for each object, 4) Kalman filtering for motion prediction, and 5) Hungarian algorithm for object association between frames. For improved performance, I'd use optical flow to track objects between detections and implement occlusion handling. The algorithm would be optimized using parallel processing for different stages of the pipeline.",
            follow_ups=[
                "How would you handle occlusions in your tracking algorithm?",
                "What approach would you take to identify the same object across multiple camera views?"
            ]
        )
        
        self._add_question(
            question="Explain how you would design a secure communication protocol for military drones operating in contested airspace.",
            category="Technical",
            difficulty="Hard",
            tags=["cybersecurity", "communication_systems", "defense_technology"],
            sample_answer="The protocol would incorporate: 1) Frequency hopping spread spectrum to resist jamming, 2) Strong encryption (AES-256) for all data, 3) Authentication using asymmetric cryptography with rotating keys, 4) Low probability of intercept/detection waveforms, 5) Redundant communication paths, 6) Minimal transmission time to reduce exposure, 7) Autonomous operation capabilities when communications are denied, and 8) Selective jamming resistance. The protocol would also include contingency modes for different threat levels and automatic fallback mechanisms.",
            follow_ups=[
                "How would you handle key distribution in this system?",
                "What countermeasures would you implement against signal spoofing attacks?"
            ]
        )
        
        # Defense technology questions
        self._add_question(
            question="Describe the key technical challenges in developing autonomous systems for defense applications compared to commercial applications.",
            category="Defense Technology",
            difficulty="Medium",
            tags=["autonomous_systems", "defense_technology"],
            sample_answer="Defense autonomous systems face unique challenges: 1) Operating in GPS-denied environments requires advanced navigation alternatives, 2) Adversarial environments demand resilience against jamming, spoofing, and physical attacks, 3) Strict requirements for minimizing false positives in target identification, 4) Need for explainable AI for critical decisions, 5) Rigorous verification and validation processes, 6) Operation in extreme environmental conditions, 7) Stringent security requirements to prevent compromise, and 8) Interoperability with legacy military systems. Unlike commercial applications, defense systems must maintain functionality with degraded sensors and communications while meeting strict rules of engagement.",
            follow_ups=[
                "How would you approach testing and validation for an autonomous defense system?",
                "What ethical considerations should be addressed when developing autonomous defense technology?"
            ]
        )
        
        self._add_question(
            question="Explain the concept of sensor fusion and how it applies to modern defense systems.",
            category="Defense Technology",
            difficulty="Medium",
            tags=["sensors", "data_fusion", "defense_technology"],
            sample_answer="Sensor fusion combines data from multiple sensors to achieve more accurate information than individual sensors can provide. In defense systems, this typically involves integrating radar, electro-optical/infrared cameras, LIDAR, acoustic sensors, and signals intelligence. The fusion process includes data alignment (synchronizing timestamps and coordinate systems), association (matching detections across sensors), state estimation (using algorithms like Kalman filters), and classification fusion. Modern approaches use deep learning for end-to-end fusion. Benefits include improved detection range, reduced false alarms, enhanced classification accuracy, and resilience against sensor denial or deception.",
            follow_ups=[
                "What algorithms would you use for real-time sensor fusion in a tactical environment?",
                "How would you handle conflicting information from different sensors?"
            ]
        )
        
        # Behavioral questions
        self._add_question(
            question="Describe a situation where you had to make a difficult technical decision with limited information. How did you approach it?",
            category="Behavioral",
            difficulty="Medium",
            tags=["decision_making", "leadership", "uncertainty"],
            sample_answer="In a previous role, I was leading the development of a critical navigation system with a tight deadline when we discovered a potential security vulnerability. With limited time to fully assess the issue, I had to decide whether to delay the release or proceed with mitigations. I approached this by: 1) Quickly assembling a cross-functional team to assess the severity, 2) Developing a threat model to understand potential impacts, 3) Identifying the minimum viable security measures needed, 4) Creating a phased approach that allowed us to release with essential protections while developing a comprehensive fix, and 5) Transparently communicating the situation and plan to stakeholders. This balanced security needs with operational requirements while maintaining trust with our users.",
            follow_ups=[
                "What would you have done differently with the benefit of hindsight?",
                "How did you communicate this decision to stakeholders who might have been disappointed?"
            ]
        )
        
        self._add_question(
            question="Tell me about a time when you had to work under extreme pressure to meet a deadline on a complex technical project.",
            category="Behavioral",
            difficulty="Medium",
            tags=["pressure", "project_management", "teamwork"],
            sample_answer="While working on a defense project, we discovered a critical performance issue just two weeks before delivery. I led the response by: 1) Organizing a war room with our top engineers, 2) Breaking down the problem into testable components, 3) Implementing a 24-hour work cycle with rotating teams, 4) Establishing clear communication channels with stakeholders, 5) Prioritizing fixes based on impact and complexity, and 6) Creating daily progress metrics to maintain focus. We identified that the issue stemmed from an unexpected interaction between two subsystems. By redesigning the interface and optimizing the data flow, we resolved the issue three days before delivery. This experience taught me the importance of systematic debugging, clear communication under pressure, and maintaining team morale during intense work periods.",
            follow_ups=[
                "How did you ensure team members didn't burn out during this intense period?",
                "What processes did you implement afterward to prevent similar issues in the future?"
            ]
        )
        
        # System design questions
        self._add_question(
            question="Design a system for coordinating multiple autonomous vehicles in a battlefield environment with unreliable communications.",
            category="System Design",
            difficulty="Hard",
            tags=["distributed_systems", "autonomous_systems", "resilience"],
            sample_answer="The system would use a hierarchical architecture with these components: 1) Individual vehicle autonomy layer with mission objectives, constraints, and decision-making capabilities, 2) Peer-to-peer mesh networking with store-and-forward capabilities, 3) Distributed consensus algorithms for coordination without central control, 4) Shared world model with conflict resolution for inconsistent observations, 5) Intent broadcasting to share planned actions, 6) Priority-based communication protocol that adapts to available bandwidth, 7) Fallback coordination modes using pre-planned contingencies, and 8) Implicit coordination through observable behaviors when communication is impossible. The system would use Byzantine fault-tolerant algorithms to handle potentially compromised nodes and would maintain mission effectiveness with progressive degradation as communication quality decreases.",
            follow_ups=[
                "How would you test this system's resilience to communication failures?",
                "What mechanisms would you implement to prevent friendly fire incidents?"
            ]
        )
        
        # Algorithm questions
        self._add_question(
            question="Implement an efficient algorithm for path planning in a dynamic environment with moving obstacles.",
            category="Algorithms",
            difficulty="Hard",
            tags=["algorithms", "path_planning", "autonomous_systems"],
            sample_answer="I would implement a hybrid approach combining Rapidly-exploring Random Trees (RRT*) with Model Predictive Control (MPC). The algorithm would: 1) Use RRT* to efficiently explore the space and find an initial path, 2) Predict obstacle trajectories using Kalman filtering, 3) Apply MPC to optimize the path considering vehicle dynamics and predicted obstacle movements, 4) Maintain a dynamic occupancy grid that updates with new sensor data, 5) Implement a receding horizon approach to continuously replan as new information becomes available, and 6) Use different planning horizons (short-term for immediate obstacle avoidance, long-term for goal-directed behavior). The algorithm would be optimized using parallel processing for prediction and planning steps, with fallback to simpler reactive behaviors when computational resources are constrained.",
            follow_ups=[
                "How would you handle uncertainty in obstacle trajectory predictions?",
                "What modifications would you make to ensure real-time performance on embedded hardware?"
            ]
        )
        
    def _add_question(self, question: str, category: str, difficulty: str, 
                    tags: List[str], sample_answer: str, 
                    follow_ups: Optional[List[str]] = None) -> None:
        """Add a question to the database"""
        q = InterviewQuestion(
            question=question,
            category=category,
            difficulty=difficulty,
            tags=tags,
            sample_answer=sample_answer,
            follow_ups=follow_ups
        )
        self.questions[q.id] = q
        
    async def start(self):
        """Start the agent"""
        self.running = True
        logger.info(f"Started {self.name} agent")
        
    async def stop(self):
        """Stop the agent"""
        self.running = False
        logger.info(f"Stopped {self.name} agent")
        
    async def run(self):
        """Main execution loop"""
        self.running = True
        try:
            while self.running:
                # Main agent logic here
                await self._process_cycle()
                await asyncio.sleep(1)  # Prevent CPU hogging
        except Exception as e:
            logger.error(f"Error in agent execution: {e}")
            self.running = False
        finally:
            logger.info(f"Agent {self.name} execution completed")
            
    async def _process_cycle(self):
        """Process a single execution cycle"""
        # Implement the core agent logic here
        pass
    
    async def create_preparation_plan(self, candidate_name: str, position: str,
                                    experience_level: str, focus_areas: List[str],
                                    days_until_interview: int) -> Dict[str, Any]:
        """
        Create a personalized interview preparation plan
        
        Args:
            candidate_name: Name of the candidate
            position: Position being applied for
            experience_level: Experience level (junior, mid, senior)
            focus_areas: Areas to focus on (e.g., algorithms, system design)
            days_until_interview: Number of days until the interview
            
        Returns:
            Dictionary with preparation plan
        """
        logger.info(f"Creating preparation plan for {candidate_name} applying for {position}")
        
        # Create plan
        plan = InterviewPreparationPlan(
            candidate_name=candidate_name,
            position=position,
            experience_level=experience_level,
            focus_areas=focus_areas
        )
        
        # Filter questions based on focus areas and experience level
        difficulty_mapping = {
            "junior": ["Easy", "Medium"],
            "mid": ["Medium", "Hard"],
            "senior": ["Hard"]
        }
        
        appropriate_difficulties = difficulty_mapping.get(experience_level.lower(), ["Medium", "Hard"])
        
        # Group questions by category
        questions_by_category = {}
        for question in self.questions.values():
            # Check if question matches focus areas
            if not any(area.lower() in tag.lower() for area in focus_areas for tag in question.tags):
                continue
                
            # Check if difficulty is appropriate
            if question.difficulty not in appropriate_difficulties:
                continue
                
            # Add to category
            if question.category not in questions_by_category:
                questions_by_category[question.category] = []
            questions_by_category[question.category].append(question)
        
        # Create sections based on categories
        for category, questions in questions_by_category.items():
            # Limit number of questions based on category
            if category == "Technical":
                selected_questions = questions[:5]
                hours = 8.0
            elif category == "System Design":
                selected_questions = questions[:3]
                hours = 6.0
            elif category == "Algorithms":
                selected_questions = questions[:4]
                hours = 10.0
            elif category == "Defense Technology":
                selected_questions = questions[:4]
                hours = 6.0
            elif category == "Behavioral":
                selected_questions = questions[:3]
                hours = 4.0
            else:
                selected_questions = questions[:2]
                hours = 3.0
                
            # Add section if there are questions
            if selected_questions:
                plan.add_section(
                    title=f"{category} Interview Preparation",
                    description=f"Preparation for {category.lower()} interview questions at Anduril",
                    questions=selected_questions,
                    estimated_hours=hours
                )
        
        # Add resources based on focus areas
        resources = [
            {
                "title": "Anduril Industries - About",
                "url": "https://www.anduril.com/about/",
                "type": "Company Background",
                "areas": ["all"]
            },
            {
                "title": "System Design Interview Guide",
                "url": "https://github.com/donnemartin/system-design-primer",
                "type": "Technical Resource",
                "areas": ["system_design"]
            },
            {
                "title": "Algorithms and Data Structures Review",
                "url": "https://leetcode.com/",
                "type": "Practice Platform",
                "areas": ["algorithms"]
            },
            {
                "title": "Modern Defense Technology Overview",
                "url": "https://www.darpa.mil/work-with-us/opportunities",
                "type": "Industry Knowledge",
                "areas": ["defense_technology"]
            },
            {
                "title": "Autonomous Systems Architecture",
                "url": "https://arxiv.org/abs/2003.06417",
                "type": "Technical Paper",
                "areas": ["autonomous_systems"]
            }
        ]
        
        for resource in resources:
            if "all" in resource["areas"] or any(area in focus_areas for area in resource["areas"]):
                plan.add_resource(
                    title=resource["title"],
                    url=resource["url"],
                    type=resource["type"]
                )
        
        # Generate schedule
        schedule = plan.generate_schedule(min(days_until_interview, 14))
        
        # Create visualization
        plt.figure(figsize=(12, 8))
        
        # Pie chart of hours by category
        plt.subplot(2, 2, 1)
        categories = [section["title"].split()[0] for section in plan.sections]
        hours = [section["estimated_hours"] for section in plan.sections]
        plt.pie(hours, labels=categories, autopct='%1.1f%%')
        plt.title('Study Hours by Category')
        
        # Bar chart of questions by category
        plt.subplot(2, 2, 2)
        question_counts = [len(section["questions"]) for section in plan.sections]
        plt.bar(categories, question_counts)
        plt.title('Questions by Category')
        plt.xticks(rotation=45, ha='right')
        
        # Line chart of daily study hours
        plt.subplot(2, 2, 3)
        days = [day["day"] for day in schedule]
        daily_hours = [day["estimated_hours"] for day in schedule]
        plt.plot(days, daily_hours, marker='o')
        plt.title('Daily Study Hours')
        plt.xlabel('Day')
        plt.ylabel('Hours')
        
        # Text summary
        plt.subplot(2, 2, 4)
        plt.axis('off')
        
        summary_text = f"Interview Preparation Plan for {candidate_name}\n\n"
        summary_text += f"Position: {position}\n"
        summary_text += f"Experience Level: {experience_level}\n"
        summary_text += f"Focus Areas: {', '.join(focus_areas)}\n\n"
        
        summary_text += f"Total Study Hours: {plan.total_hours():.1f}\n"
        summary_text += f"Days Until Interview: {days_until_interview}\n"
        summary_text += f"Daily Study Target: {plan.total_hours() / days_until_interview:.1f} hours\n\n"
        
        summary_text += f"Number of Questions: {sum(question_counts)}\n"
        summary_text += f"Number of Resources: {len(plan.resources)}"
        
        plt.text(0, 0.5, summary_text, fontsize=10, verticalalignment='center')
        
        plt.tight_layout()
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/prep_plan_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return {
            "plan": plan.to_dict(),
            "schedule": schedule,
            "visualization": filename
        }
    
    async def generate_practice_questions(self, topic: str, difficulty: str, 
                                        count: int = 5) -> Dict[str, Any]:
        """
        Generate practice questions for a specific topic
        
        Args:
            topic: Topic for questions (e.g., algorithms, system design)
            difficulty: Difficulty level (easy, medium, hard)
            count: Number of questions to generate
            
        Returns:
            Dictionary with practice questions
        """
        logger.info(f"Generating {count} {difficulty} practice questions for {topic}")
        
        # Filter questions by topic and difficulty
        matching_questions = []
        for question in self.questions.values():
            if (topic.lower() in question.category.lower() or 
                any(topic.lower() in tag.lower() for tag in question.tags)):
                if question.difficulty.lower() == difficulty.lower():
                    matching_questions.append(question)
        
        # Select random questions
        selected_questions = []
        if matching_questions:
            selected_questions = random.sample(
                matching_questions, 
                min(count, len(matching_questions))
            )
            
        # If we don't have enough questions, generate some based on patterns
        while len(selected_questions) < count:
            # Generate a question based on templates
            if topic.lower() == "algorithms":
                new_question = self._generate_algorithm_question(difficulty)
            elif topic.lower() == "system design":
                new_question = self._generate_system_design_question(difficulty)
            elif topic.lower() == "defense technology":
                new_question = self._generate_defense_technology_question(difficulty)
            else:
                new_question = self._generate_general_question(topic, difficulty)
                
            selected_questions.append(new_question)
            
        # Create visualization
        plt.figure(figsize=(10, 6))
        
        # Create a difficulty distribution chart
        difficulties = ["Easy", "Medium", "Hard"]
        difficulty_counts = [0, 0, 0]
        
        for question in selected_questions:
            if question.difficulty == "Easy":
                difficulty_counts[0] += 1
            elif question.difficulty == "Medium":
                difficulty_counts[1] += 1
            elif question.difficulty == "Hard":
                difficulty_counts[2] += 1
                
        plt.bar(difficulties, difficulty_counts, color=['green', 'orange', 'red'])
        plt.title(f'Practice Questions for {topic.capitalize()}')
        plt.xlabel('Difficulty')
        plt.ylabel('Number of Questions')
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/practice_questions_{topic}_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return {
            "topic": topic,
            "difficulty": difficulty,
            "questions": [q.to_dict() for q in selected_questions],
            "visualization": filename
        }
    
    def _generate_algorithm_question(self, difficulty: str) -> InterviewQuestion:
        """Generate an algorithm question based on difficulty"""
        if difficulty.lower() == "easy":
            question = "Implement an algorithm to find all pairs of integers in an array that sum to a given target."
            sample_answer = "I would use a hash map approach. First, create an empty hash map. Then iterate through the array once, and for each element x, check if target-x exists in the hash map. If it does, we've found a pair. If not, add x to the hash map. This gives us O(n) time complexity and O(n) space complexity."
            
        elif difficulty.lower() == "medium":
            question = "Design an algorithm for detecting and tracking multiple objects in a video feed from a drone."
            sample_answer = "I would implement a pipeline using background subtraction to identify moving objects, followed by contour detection to isolate distinct objects. Then I'd use feature extraction with SIFT or ORB descriptors for each object, and apply a Kalman filter for motion prediction. The Hungarian algorithm would be used for object association between frames. For optimization, I'd implement parallel processing for different stages of the pipeline."
            
        else:  # hard
            question = "Implement a distributed algorithm for coordinating a swarm of drones to efficiently search an area while maintaining communication constraints."
            sample_answer = "I would implement a distributed frontier-based exploration algorithm. Each drone maintains a local occupancy grid and frontier cells (unexplored areas at the boundary of explored space). Drones share their maps using a consensus protocol over a mesh network. To assign frontiers, I'd use a market-based approach where drones bid on frontiers based on distance and information gain. To maintain connectivity, I'd implement a constraint that ensures each drone maintains line-of-sight with at least two other drones. The algorithm adapts to communication failures by having drones return to last known good communication points when disconnected."
            
        return InterviewQuestion(
            question=question,
            category="Algorithms",
            difficulty=difficulty.capitalize(),
            tags=["algorithms", "coding", "autonomous_systems"],
            sample_answer=sample_answer,
            follow_ups=["How would you optimize this algorithm?", 
                       "What edge cases should be considered?"]
        )
    
    def _generate_system_design_question(self, difficulty: str) -> InterviewQuestion:
        """Generate a system design question based on difficulty"""
        if difficulty.lower() == "easy":
            question = "Design a simple telemetry system for collecting and analyzing data from a small fleet of drones."
            sample_answer = "I would design a system with these components: 1) On-drone telemetry collection module that samples sensor data at appropriate rates, 2) Local storage buffer on each drone to handle communication interruptions, 3) Secure communication protocol using TLS for data transmission, 4) Cloud-based data ingestion service with authentication, 5) Time-series database for efficient storage and querying, 6) Basic analytics service for generating reports and visualizations, and 7) Alert system for anomaly detection. The system would prioritize reliability, security, and scalability while minimizing bandwidth usage."
            
        elif difficulty.lower() == "medium":
            question = "Design a real-time object detection and tracking system for border security that can operate with limited connectivity."
            sample_answer = "The system would consist of: 1) Edge devices with cameras and local processing capabilities, 2) On-device ML models for initial object detection and classification, 3) Local data storage with priority-based retention policies, 4) Mesh networking between nearby devices for resilience, 5) Bandwidth-aware synchronization protocol that prioritizes critical detections, 6) Central command center with advanced analytics capabilities, 7) Human-in-the-loop verification for high-confidence alerts, and 8) Fallback modes for operation during connectivity loss. Key challenges include power management, environmental hardening, false positive reduction, and ensuring security of the entire pipeline."
            
        else:  # hard
            question = "Design a comprehensive autonomous defense system that integrates aerial, ground, and underwater vehicles for maritime border protection."
            sample_answer = "This multi-domain system would include: 1) Layered sensing architecture with long-range radar, electro-optical/infrared cameras, sonar arrays, and signals intelligence, 2) Heterogeneous autonomous vehicles (UAVs, USVs, UUVs) with complementary capabilities, 3) Distributed command and control with hierarchical decision-making, 4) Multi-level fusion engine combining data across domains and time horizons, 5) Secure, jam-resistant communication network with graceful degradation, 6) AI-powered anomaly detection and threat assessment, 7) Autonomous coordination protocols for cross-domain operations, 8) Human oversight with appropriate authorization levels, and 9) Simulation and training environment for continuous improvement. The system would be designed with modularity to allow technology refresh and mission adaptation while maintaining strict security controls and audit capabilities."
            
        return InterviewQuestion(
            question=question,
            category="System Design",
            difficulty=difficulty.capitalize(),
            tags=["system_design", "architecture", "defense_technology"],
            sample_answer=sample_answer,
            follow_ups=["How would you ensure the security of this system?", 
                       "How would the system handle failure scenarios?"]
        )
    
    def _generate_defense_technology_question(self, difficulty: str) -> InterviewQuestion:
        """Generate a defense technology question based on difficulty"""
        if difficulty.lower() == "easy":
            question = "Explain the concept of sensor fusion and its applications in modern defense systems."
            sample_answer = "Sensor fusion combines data from multiple sensors to achieve more accurate information than individual sensors can provide. In defense systems, this typically involves integrating radar, electro-optical/infrared cameras, LIDAR, acoustic sensors, and signals intelligence. The fusion process includes data alignment, association, state estimation, and classification fusion. Benefits include improved detection range, reduced false alarms, enhanced classification accuracy, and resilience against sensor denial or deception."
            
        elif difficulty.lower() == "medium":
            question = "Discuss the technical challenges of operating autonomous systems in GPS-denied environments and potential solutions."
            sample_answer = "Operating in GPS-denied environments presents several challenges: 1) Position drift without absolute references, 2) Difficulty in coordination between multiple systems, and 3) Navigation hazards without accurate positioning. Solutions include: 1) Visual-inertial odometry using cameras and IMUs for local positioning, 2) Terrain relative navigation by matching sensor data to known maps, 3) Celestial navigation using star trackers, 4) Signals of opportunity from existing RF sources, 5) Collaborative localization between multiple platforms, and 6) Advanced filtering techniques like particle filters to combine multiple imperfect sources. The most robust approaches use a combination of these techniques with appropriate sensor fusion algorithms."
            
        else:  # hard
            question = "Analyze the technical and ethical considerations in developing autonomous weapons systems with increasing levels of decision-making authority."
            sample_answer = "Technical considerations include: 1) Reliability of target identification in complex environments, 2) Robustness against adversarial attacks or deception, 3) Verification and validation of decision-making algorithms, 4) Fail-safe mechanisms and human override capabilities, 5) Auditability of decisions for accountability. Ethical considerations include: 1) Meaningful human control and appropriate autonomy levels, 2) Proportionality and distinction in targeting decisions, 3) Accountability for autonomous decisions, 4) Risk of lowering threshold for conflict, 5) International humanitarian law compliance. A balanced approach would implement a sliding scale of autonomy based on operational context, with higher-risk decisions requiring more human involvement, combined with rigorous testing in realistic scenarios and clear doctrine for employment."
            
        return InterviewQuestion(
            question=question,
            category="Defense Technology",
            difficulty=difficulty.capitalize(),
            tags=["defense_technology", "autonomous_systems", "ethics"],
            sample_answer=sample_answer,
            follow_ups=["How might these technologies evolve in the next decade?", 
                       "What are the implications for military doctrine?"]
        )
    
    def _generate_general_question(self, topic: str, difficulty: str) -> InterviewQuestion:
        """Generate a general question based on topic and difficulty"""
        if topic.lower() == "behavioral":
            question = "Describe a situation where you had to make a difficult technical decision with limited information. How did you approach it?"
            category = "Behavioral"
            tags = ["decision_making", "leadership", "uncertainty"]
            sample_answer = "In a previous role, I was leading the development of a critical navigation system with a tight deadline when we discovered a potential security vulnerability. With limited time to fully assess the issue, I had to decide whether to delay the release or proceed with mitigations. I approached this by quickly assembling a cross-functional team to assess the severity, developing a threat model, identifying minimum viable security measures, creating a phased approach, and transparently communicating with stakeholders. This balanced security needs with operational requirements while maintaining trust."
            
        elif topic.lower() == "technical":
            question = "Explain how you would design a secure communication protocol for military drones operating in contested airspace."
            category = "Technical"
            tags = ["cybersecurity", "communication_systems", "defense_technology"]
            sample_answer = "The protocol would incorporate frequency hopping spread spectrum to resist jamming, strong encryption for all data, authentication using asymmetric cryptography with rotating keys, low probability of intercept waveforms, redundant communication paths, minimal transmission time, autonomous operation capabilities when communications are denied, and selective jamming resistance. The protocol would also include contingency modes for different threat levels and automatic fallback mechanisms."
            
        else:
            question = f"Explain how you would approach solving a complex problem related to {topic} in a defense context."
            category = "General"
            tags = [topic, "problem_solving", "defense_technology"]
            sample_answer = f"I would approach this by first clearly defining the problem and its constraints, particularly those unique to defense applications. Then I would research existing solutions and their limitations, consult with domain experts, and break down the problem into manageable components. For each component, I would develop and evaluate multiple approaches, considering factors like reliability, security, and performance in adverse conditions. I would create prototypes to test critical assumptions, integrate the components with appropriate interfaces, and implement rigorous testing including edge cases and failure modes. Throughout the process, I would maintain documentation of design decisions and trade-offs."
            
        return InterviewQuestion(
            question=question,
            category=category,
            difficulty=difficulty.capitalize(),
            tags=tags,
            sample_answer=sample_answer,
            follow_ups=["Can you provide a specific example?", 
                       "How would you handle stakeholder disagreements?"]
        )
    
    async def analyze_resume(self, resume_text: str) -> Dict[str, Any]:
        """
        Analyze a resume for Anduril interview preparation
        
        Args:
            resume_text: Text content of the resume
            
        Returns:
            Dictionary with analysis results
        """
        logger.info("Analyzing resume for Anduril interview preparation")
        
        # Extract key information
        skills = self._extract_skills(resume_text)
        experience = self._extract_experience(resume_text)
        education = self._extract_education(resume_text)
        projects = self._extract_projects(resume_text)
        
        # Identify strengths and weaknesses
        strengths = []
        weaknesses = []
        
        # Check for defense-related experience
        defense_keywords = ["defense", "military", "security", "aerospace", "autonomous", "drone"]
        has_defense_experience = any(keyword in resume_text.lower() for keyword in defense_keywords)
        
        if has_defense_experience:
            strengths.append("Defense industry experience")
        else:
            weaknesses.append("Limited defense industry experience")
            
        # Check for technical skills
        technical_skills = {
            "programming": ["python", "c++", "java", "rust", "golang"],
            "machine_learning": ["machine learning", "deep learning", "neural network", "computer vision"],
            "robotics": ["robotics", "autonomous", "control systems", "navigation"],
            "embedded": ["embedded", "firmware", "rtos", "microcontroller"],
            "systems": ["distributed systems", "cloud", "architecture", "scalability"]
        }
        
        for category, keywords in technical_skills.items():
            if any(keyword in resume_text.lower() for keyword in keywords):
                strengths.append(f"{category.replace('_', ' ').title()} skills")
            else:
                weaknesses.append(f"No mention of {category.replace('_', ' ')} skills")
                
        # Check for project experience
        project_keywords = ["project", "developed", "built", "created", "designed", "implemented"]
        has_projects = any(keyword in resume_text.lower() for keyword in project_keywords)
        
        if has_projects:
            strengths.append("Demonstrated project experience")
        else:
            weaknesses.append("Limited project details")
            
        # Generate recommendations
        recommendations = []
        
        for weakness in weaknesses:
            if "defense industry" in weakness:
                recommendations.append("Research Anduril's products and defense applications")
                recommendations.append("Highlight transferable skills from other domains")
                
            elif "skills" in weakness:
                skill_area = weakness.split("No mention of ")[1].split(" skills")[0]
                recommendations.append(f"Add relevant {skill_area} experience or projects")
                recommendations.append(f"Consider online courses in {skill_area}")
                
            elif "project details" in weakness:
                recommendations.append("Add specific technical projects with measurable outcomes")
                recommendations.append("Highlight problem-solving approach and technologies used")
                
        # Create visualization
        plt.figure(figsize=(12, 8))
        
        # Skills word cloud
        plt.subplot(2, 2, 1)
        plt.axis('off')
        if skills:
            skill_text = "\n".join(skills)
            plt.text(0.5, 0.5, skill_text, ha='center', va='center', fontsize=10)
        plt.title('Skills')
        
        # Strengths and weaknesses
        plt.subplot(2, 2, 2)
        plt.axis('off')
        strength_text = "Strengths:\n" + "\n".join(f"✓ {s}" for s in strengths)
        weakness_text = "\nAreas for Improvement:\n" + "\n".join(f"✗ {w}" for w in weaknesses)
        plt.text(0.5, 0.5, strength_text + "\n" + weakness_text, ha='center', va='center', fontsize=10)
        plt.title('Resume Assessment')
        
        # Recommendations
        plt.subplot(2, 2, 3)
        plt.axis('off')
        rec_text = "Recommendations:\n" + "\n".join(f"• {r}" for r in recommendations)
        plt.text(0.5, 0.5, rec_text, ha='center', va='center', fontsize=10)
        plt.title('Recommendations')
        
        # Anduril fit assessment
        plt.subplot(2, 2, 4)
        
        # Calculate a simple fit score
        fit_score = len(strengths) / (len(strengths) + len(weaknesses)) * 100
        
        categories = ['Technical Skills', 'Defense Experience', 'Project Experience', 'Overall Fit']
        
        # Calculate category scores
        technical_score = sum(1 for s in strengths if "skills" in s.lower()) / len(technical_skills) * 100
        defense_score = 100 if has_defense_experience else 30
        project_score = 100 if has_projects else 40
        
        scores = [technical_score, defense_score, project_score, fit_score]
        
        plt.bar(categories, scores, color=['blue', 'green', 'orange', 'red'])
        plt.ylim(0, 100)
        plt.xticks(rotation=45, ha='right')
        plt.title('Anduril Fit Assessment')
        
        plt.tight_layout()
        
        # Save the figure
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/resume_analysis_{timestamp}.png"
        plt.savefig(filename)
        plt.close()
        
        return {
            "skills": skills,
            "experience": experience,
            "education": education,
            "projects": projects,
            "strengths": strengths,
            "weaknesses": weaknesses,
            "recommendations": recommendations,
            "fit_score": fit_score,
            "visualization": filename
        }
    
    def _extract_skills(self, text: str) -> List[str]:
        """Extract skills from resume text"""
        # Simple keyword-based extraction
        skill_keywords = [
            "python", "c++", "java", "javascript", "rust", "golang", "swift",
            "machine learning", "deep learning", "neural networks", "computer vision",
            "robotics", "autonomous systems", "control systems", "navigation",
            "embedded systems", "firmware", "rtos", "microcontrollers",
            "distributed systems", "cloud", "architecture", "scalability",
            "cybersecurity", "encryption", "authentication", "network security",
            "signal processing", "sensor fusion", "radar", "lidar",
            "project management", "agile", "scrum", "leadership"
        ]
        
        found_skills = []
        for skill in skill_keywords:
            if skill.lower() in text.lower():
                found_skills.append(skill)
                
        return found_skills
    
    def _extract_experience(self, text: str) -> List[Dict[str, str]]:
        """Extract work experience from resume text"""
        # Simple regex-based extraction
        experience_pattern = r"(?i)(.*?company|.*?inc\.?|.*?corp\.?|.*?corporation)(.*?)(\d{4})\s*-\s*(\d{4}|present)"
        matches = re.findall(experience_pattern, text)
        
        experience = []
        for match in matches:
            company = match[0].strip()
            role = match[1].strip()
            start_year = match[2].strip()
            end_year = match[3].strip()
            
            experience.append({
                "company": company,
                "role": role,
                "period": f"{start_year} - {end_year}"
            })
            
        return experience
    
    def _extract_education(self, text: str) -> List[Dict[str, str]]:
        """Extract education from resume text"""
        # Simple regex-based extraction
        education_pattern = r"(?i)(bachelor|master|phd|doctorate|bs|ms|ba|ma|b\.s\.|m\.s\.|b\.a\.|m\.a\.|ph\.d\.)(.*?)(university|college|institute|school)(.*?)(\d{4})"
        matches = re.findall(education_pattern, text)
        
        education = []
        for match in matches:
            degree = match[0].strip()
            field = match[1].strip()
            institution = match[2].strip() + match[3].strip()
            year = match[4].strip()
            
            education.append({
                "degree": degree,
                "field": field,
                "institution": institution,
                "year": year
            })
            
        return education
    
    def _extract_projects(self, text: str) -> List[str]:
        """Extract projects from resume text"""
        # Simple keyword-based extraction
        project_indicators = [
            "project:", "developed", "built", "created", "designed", "implemented",
            "led the development", "architected", "engineered"
        ]
        
        lines = text.split("\n")
        projects = []
        
        for line in lines:
            if any(indicator.lower() in line.lower() for indicator in project_indicators):
                projects.append(line.strip())
                
        return projects
        
    async def perform_specialized_task(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Perform a specialized task related to Anduril interview preparation
        
        Args:
            task_data: Data needed for the task
            
        Returns:
            Dict containing task results
        """
        logger.info(f"Performing specialized task in {self.specialization}")
        
        task_type = task_data.get("type", "")
        
        if task_type == "preparation_plan":
            return await self.create_preparation_plan(
                candidate_name=task_data.get("candidate_name", "Candidate"),
                position=task_data.get("position", "Software Engineer"),
                experience_level=task_data.get("experience_level", "mid"),
                focus_areas=task_data.get("focus_areas", ["algorithms", "system_design"]),
                days_until_interview=task_data.get("days_until_interview", 14)
            )
            
        elif task_type == "practice_questions":
            return await self.generate_practice_questions(
                topic=task_data.get("topic", "algorithms"),
                difficulty=task_data.get("difficulty", "medium"),
                count=task_data.get("count", 5)
            )
            
        elif task_type == "resume_analysis":
            return await self.analyze_resume(
                resume_text=task_data.get("resume_text", "")
            )
            
        else:
            return {"error": f"Unknown task type: {task_type}"}
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert agent to dictionary"""
        return {
            "id": self.id,
            "name": self.name,
            "created_at": self.created_at,
            "capabilities": self.capabilities,
            "specialization": self.specialization,
            "running": self.running
        }
        
async def main():
    """Main entry point"""
    agent = AndurilInterviewPreparationAgent()
    await agent.start()
    
    try:
        # Create a sample preparation plan
        plan_result = await agent.create_preparation_plan(
            candidate_name="John Doe",
            position="Senior Software Engineer",
            experience_level="senior",
            focus_areas=["algorithms", "system_design", "autonomous_systems"],
            days_until_interview=14
        )
        
        print(f"Preparation plan created. Visualization saved to: {plan_result['visualization']}")
        print(f"Total sections: {len(plan_result['plan']['sections'])}")
        print(f"Total resources: {len(plan_result['plan']['resources'])}")
        
        # Generate practice questions
        questions_result = await agent.generate_practice_questions(
            topic="system_design",
            difficulty="hard",
            count=3
        )
        
        print(f"Practice questions generated. Visualization saved to: {questions_result['visualization']}")
        for i, question in enumerate(questions_result['questions']):
            print(f"Question {i+1}: {question['question']}")
        
    finally:
        await agent.stop()

if __name__ == "__main__":
    asyncio.run(main())
